/**
 * Authentication API Integration Tests
 * Tests the complete authentication flow with real API endpoints
 */

import request from 'supertest';
import jwt from 'jsonwebtoken';
import bcrypt from 'bcrypt';

// Import the app directly to test real API endpoints
const app = require('../../app').default;
const UserModel = require('../../models/User').default;

describe('Authentication API Integration Tests', () => {
  describe('POST /api/auth/signup', () => {
    it('should register a new user successfully', async () => {
      const userData = {
        userName: 'integrationtest',
        firstName: 'Integration',
        lastName: 'Test',
        phone: '+1234567890',
        password: 'testpassword123',
        role: 'Guest',
      };

      const response = await request(app)
        .post('/api/auth/signup')
        .send(userData)
        .expect(201);

      expect(response.body).toHaveProperty('token');
      expect(response.body).toHaveProperty(
        'message',
        'User created successfully',
      );

      // Verify user exists in database
      const user = await UserModel.findOne({ userName: userData.userName });
      expect(user).toBeTruthy();
      expect(user.firstName).toBe(userData.firstName);
      expect(user.role).toBe(userData.role);
      expect(user.provider).toBe('Local');

      // Verify password is hashed
      const isValidPassword = await bcrypt.compare(
        userData.password,
        user.password,
      );
      expect(isValidPassword).toBe(true);

      // Verify token is valid
      const decoded = jwt.verify(
        response.body.token,
        process.env.SECRET!,
      ) as any;
      expect(decoded._id).toBe(user._id.toString());
    });

    it('should reject registration with missing fields', async () => {
      const incompleteData = {
        userName: 'incomplete',
        firstName: 'Test',
        // Missing required fields
      };

      const response = await request(app)
        .post('/api/auth/signup')
        .send(incompleteData)
        .expect(400);

      expect(response.body).toHaveProperty('error');
    });

    it('should reject duplicate usernames', async () => {
      const userData = {
        userName: 'duplicatetest',
        firstName: 'Duplicate',
        lastName: 'Test',
        phone: '+1234567890',
        password: 'password123',
        role: 'Guest',
      };

      // First registration
      await request(app).post('/api/auth/signup').send(userData).expect(201);

      // Second registration with same username
      const duplicateData = {
        ...userData,
        phone: '+0987654321',
      };

      const response = await request(app)
        .post('/api/auth/signup')
        .send(duplicateData)
        .expect(400);

      expect(response.body.error).toContain('already in use');
    });
  });

  describe('POST /api/auth/login', () => {
    beforeEach(async () => {
      // Create a test user for login tests
      const hashedPassword = await bcrypt.hash('logintest123', 12);
      await UserModel.create({
        userName: 'logintest',
        firstName: 'Login',
        lastName: 'Test',
        phone: '+1234567890',
        password: hashedPassword,
        provider: 'Local',
        role: 'Host',
      });
    });

    it('should login successfully with correct credentials', async () => {
      const loginData = {
        userName: 'logintest',
        password: 'logintest123',
      };

      const response = await request(app)
        .post('/api/auth/login')
        .send(loginData)
        .expect(200);

      expect(response.body).toHaveProperty('token');
      expect(response.body).toHaveProperty('message', 'Login Successful');

      // Verify token is valid
      const decoded = jwt.verify(
        response.body.token,
        process.env.SECRET!,
      ) as any;
      expect(decoded._id).toBeDefined();

      // Verify token expiration (3 days)
      const tokenDuration = decoded.exp - decoded.iat;
      const threeDaysInSeconds = 3 * 24 * 60 * 60;
      expect(tokenDuration).toBe(threeDaysInSeconds);
    });

    it('should reject login with wrong password', async () => {
      const loginData = {
        userName: 'logintest',
        password: 'wrongpassword',
      };

      const response = await request(app)
        .post('/api/auth/login')
        .send(loginData)
        .expect(400);

      expect(response.body.error).toContain('Incorrect password');
    });

    it('should reject login with non-existent user', async () => {
      const loginData = {
        userName: 'nonexistent',
        password: 'password123',
      };

      const response = await request(app)
        .post('/api/auth/login')
        .send(loginData)
        .expect(400);

      expect(response.body.error).toContain('Username not found');
    });
  });

  describe('POST /api/auth/google', () => {
    it('should have Google authentication endpoint', async () => {
      const response = await request(app)
        .post('/api/auth/google')
        .send({ credential: 'invalid-token' });

      // Endpoint should exist (will fail without valid Google token)
      expect(response.status).toBeDefined();
      expect(response.status).toBeGreaterThanOrEqual(400);
    });
  });

  describe('Full Authentication Flow', () => {
    it('should complete signup -> login flow', async () => {
      // Step 1: Register user
      const userData = {
        userName: 'flowtest',
        firstName: 'Flow',
        lastName: 'Test',
        phone: '+1234567890',
        password: 'flowtest123',
        role: 'Guest',
      };

      const signupResponse = await request(app)
        .post('/api/auth/signup')
        .send(userData)
        .expect(201);

      expect(signupResponse.body).toHaveProperty('token');
      const signupToken = signupResponse.body.token;

      // Step 2: Login with same credentials
      const loginResponse = await request(app)
        .post('/api/auth/login')
        .send({
          userName: userData.userName,
          password: userData.password,
        })
        .expect(200);

      expect(loginResponse.body).toHaveProperty('token');
      const loginToken = loginResponse.body.token;

      // Both tokens should be valid but different (different timestamps)
      const signupDecoded = jwt.decode(signupToken) as any;
      const loginDecoded = jwt.decode(loginToken) as any;

      expect(signupDecoded._id).toBe(loginDecoded._id);
      expect(signupDecoded.iat).not.toBe(loginDecoded.iat);
    });

    it('should handle concurrent user registrations', async () => {
      const users = [
        {
          userName: 'concurrent1',
          firstName: 'Concurrent',
          lastName: 'One',
          phone: '+1111111111',
          password: 'password123',
          role: 'Guest',
        },
        {
          userName: 'concurrent2',
          firstName: 'Concurrent',
          lastName: 'Two',
          phone: '+2222222222',
          password: 'password123',
          role: 'Host',
        },
        {
          userName: 'concurrent3',
          firstName: 'Concurrent',
          lastName: 'Three',
          phone: '+3333333333',
          password: 'password123',
          role: 'Guest',
        },
      ];

      // Register users concurrently
      const promises = users.map((user) =>
        request(app).post('/api/auth/signup').send(user),
      );

      const responses = await Promise.all(promises);

      // All should succeed
      responses.forEach((response) => {
        expect(response.status).toBe(201);
        expect(response.body).toHaveProperty('token');
      });

      // Verify all users exist in database
      for (const user of users) {
        const dbUser = await UserModel.findOne({ userName: user.userName });
        expect(dbUser).toBeTruthy();
        expect(dbUser.role).toBe(user.role);
      }
    });
  });

  describe('Security Tests', () => {
    it('should not expose sensitive information in responses', async () => {
      const userData = {
        userName: 'securitytest',
        firstName: 'Security',
        lastName: 'Test',
        phone: '+1234567890',
        password: 'securepassword123',
        role: 'Guest',
      };

      const signupResponse = await request(app)
        .post('/api/auth/signup')
        .send(userData);

      // Response should not contain password
      expect(signupResponse.body).not.toHaveProperty('password');
      expect(JSON.stringify(signupResponse.body)).not.toContain(
        'securepassword123',
      );

      const loginResponse = await request(app).post('/api/auth/login').send({
        userName: userData.userName,
        password: userData.password,
      });

      // Response should not contain password
      expect(loginResponse.body).not.toHaveProperty('password');
      expect(JSON.stringify(loginResponse.body)).not.toContain(
        'securepassword123',
      );
    });

    it('should rate limit authentication attempts', async () => {
      // This would require implementing rate limiting
      // For now, we test that multiple failed attempts don't crash the server
      const loginData = {
        userName: 'nonexistent',
        password: 'wrongpassword',
      };

      const promises = Array(5)
        .fill(null)
        .map(() => request(app).post('/api/auth/login').send(loginData));

      const responses = await Promise.all(promises);

      // All should fail but not crash
      responses.forEach((response) => {
        expect(response.status).toBe(400);
        expect(response.body).toHaveProperty('error');
      });
    });

    it('should handle malformed authentication requests', async () => {
      const malformedRequests = [
        {},
        { userName: null },
        { password: null },
        { userName: '', password: '' },
      ];

      for (const badRequest of malformedRequests) {
        const response = await request(app)
          .post('/api/auth/login')
          .send(badRequest);

        expect(response.status).toBeGreaterThanOrEqual(400);
        expect(response.body).toHaveProperty('error');
      }
    });
  });

  describe('Database Isolation Tests', () => {
    it('should use test database environment', () => {
      expect(process.env.NODE_ENV).toBe('test');
    });

    it('should not affect production data', async () => {
      // Create test user
      const userData = {
        userName: 'isolationtest',
        firstName: 'Isolation',
        lastName: 'Test',
        phone: '+1234567890',
        password: 'password123',
        role: 'Guest',
      };

      await request(app).post('/api/auth/signup').send(userData).expect(201);

      // Verify user exists in test database
      const user = await UserModel.findOne({ userName: userData.userName });
      expect(user).toBeTruthy();

      // This test ensures we're using the test database setup from our test configuration
      expect(user._id).toBeDefined();
    });
  });
});
