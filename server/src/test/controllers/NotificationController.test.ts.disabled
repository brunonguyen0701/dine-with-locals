import request from 'supertest';
import testApp from '../testApp';
import User from '../../models/User';
import Blog from '../../models/Blog';
import Notification from '../../models/Notification';
import jwt from 'jsonwebtoken';
import { createTestUser, createTestBlog } from '../helpers/testHelpers';

describe('NotificationController', () => {
  let testUser: any;
  let senderUser: any;
  let authToken: string;
  let testBlog: any;

  beforeEach(async () => {
    // Create test recipient user
    const recipientData = await createTestUser({
      userName: 'recipient',
      firstName: 'Recipient',
      lastName: 'User',
      email: 'recipient@example.com',
    });
    testUser = recipientData.user;

    // Create test sender user
    const senderData = await createTestUser({
      userName: 'sender',
      firstName: 'Sender',
      lastName: 'User',
      email: 'sender@example.com',
    });
    senderUser = senderData.user;

    // Generate JWT token
    authToken = jwt.sign(
      { _id: testUser._id, email: testUser.email },
      process.env.SECRET || 'test-secret',
      { expiresIn: '1h' },
    );

    // Create test blog
    testBlog = await createTestBlog(testUser._id, {
      blogTitle: 'Test Blog for Notifications',
      blogContent: 'This is a test blog for notification testing',
    });
  });

  describe('GET /api/notifications/:userId', () => {
    beforeEach(async () => {
      // Create test notifications
      const notifications = [
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post',
          blogId: testBlog._id,
          blogTitle: testBlog.blogTitle,
          isRead: false,
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'comment',
          message: 'commented on your blog post',
          blogId: testBlog._id,
          blogTitle: testBlog.blogTitle,
          isRead: true,
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post again',
          blogId: testBlog._id,
          blogTitle: testBlog.blogTitle,
          isRead: false,
        },
      ];

      await Notification.insertMany(notifications);
    });

    it('should get all notifications for a user with default pagination', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.notifications).toBeDefined();
      expect(Array.isArray(response.body.notifications)).toBe(true);
      expect(response.body.notifications.length).toBe(3);
      expect(response.body.pagination).toBeDefined();
      expect(response.body.pagination.currentPage).toBe(1);
      expect(response.body.pagination.limit).toBe(20);
      expect(response.body.unreadCount).toBe(2);
    });

    it('should get notifications with custom pagination', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .query({ page: 1, limit: 2 })
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.notifications.length).toBe(2);
      expect(response.body.pagination.limit).toBe(2);
      expect(response.body.pagination.totalCount).toBe(3);
      expect(response.body.pagination.totalPages).toBe(2);
    });

    it('should get only unread notifications when unreadOnly is true', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .query({ unreadOnly: 'true' })
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.notifications.length).toBe(2);
      response.body.notifications.forEach((notification: any) => {
        expect(notification.isRead).toBe(false);
      });
    });

    it('should return notifications sorted by creation date (newest first)', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      const notifications = response.body.notifications;
      for (let i = 1; i < notifications.length; i++) {
        const current = new Date(notifications[i].createdAt);
        const previous = new Date(notifications[i - 1].createdAt);
        expect(current.getTime()).toBeLessThanOrEqual(previous.getTime());
      }
    });

    it('should include populated sender and blog data', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      const notification = response.body.notifications[0];
      expect(notification.senderId).toBeDefined();
      expect(notification.senderId.userName).toBe(senderUser.userName);
      expect(notification.senderId.firstName).toBe(senderUser.firstName);
      expect(notification.senderId.password).toBeUndefined(); // Should not expose password
      expect(notification.blogId).toBeDefined();
      expect(notification.blogId.blogTitle).toBe(testBlog.blogTitle);
    });

    it('should return 400 for invalid user ID format', async () => {
      const response = await request(testApp)
        .get('/api/notifications/invalid-id')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(response.body.error).toBe('Invalid user ID format');
    });

    it('should handle empty notifications gracefully', async () => {
      // Clear all notifications
      await Notification.deleteMany({});

      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.notifications).toEqual([]);
      expect(response.body.unreadCount).toBe(0);
      expect(response.body.pagination.totalCount).toBe(0);
    });
  });

  describe('PUT /api/notifications/:notificationId/read', () => {
    let unreadNotification: any;

    beforeEach(async () => {
      unreadNotification = new Notification({
        recipientId: testUser._id,
        senderId: senderUser._id,
        type: 'like',
        message: 'liked your blog post',
        blogId: testBlog._id,
        blogTitle: testBlog.blogTitle,
        isRead: false,
      });
      await unreadNotification.save();
    });

    it('should mark notification as read successfully', async () => {
      const response = await request(testApp)
        .put(`/api/notifications/${unreadNotification._id}/read`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.isRead).toBe(true);
      expect(response.body._id.toString()).toBe(
        unreadNotification._id.toString(),
      );

      // Verify in database
      const updatedNotification = await Notification.findById(
        unreadNotification._id,
      );
      expect(updatedNotification?.isRead).toBe(true);
    });

    it('should return 400 for invalid notification ID format', async () => {
      const response = await request(testApp)
        .put('/api/notifications/invalid-id/read')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(response.body.error).toBe('Invalid notification ID format');
    });

    it('should return 404 for non-existent notification', async () => {
      const nonExistentId = '507f1f77bcf86cd799439011';

      const response = await request(testApp)
        .put(`/api/notifications/${nonExistentId}/read`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);

      expect(response.body.error).toBe('Notification not found');
    });

    it('should handle already read notifications', async () => {
      // Mark as read first
      await Notification.findByIdAndUpdate(unreadNotification._id, {
        isRead: true,
      });

      const response = await request(testApp)
        .put(`/api/notifications/${unreadNotification._id}/read`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.isRead).toBe(true);
    });
  });

  describe('PUT /api/notifications/users/:userId/read-all', () => {
    beforeEach(async () => {
      // Create multiple unread notifications
      const notifications = [
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post 1',
          blogId: testBlog._id,
          isRead: false,
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'comment',
          message: 'commented on your blog post 2',
          blogId: testBlog._id,
          isRead: false,
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post 3',
          blogId: testBlog._id,
          isRead: true, // Already read
        },
      ];

      await Notification.insertMany(notifications);
    });

    it('should mark all unread notifications as read', async () => {
      const response = await request(testApp)
        .put(`/api/notifications/users/${testUser._id}/read-all`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.message).toBe('All notifications marked as read');

      // Verify all notifications are now read
      const unreadCount = await Notification.countDocuments({
        recipientId: testUser._id,
        isRead: false,
      });
      expect(unreadCount).toBe(0);
    });

    it('should return 400 for invalid user ID format', async () => {
      const response = await request(testApp)
        .put('/api/notifications/users/invalid-id/read-all')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(response.body.error).toBe('Invalid user ID format');
    });

    it('should handle users with no unread notifications', async () => {
      // Mark all notifications as read first
      await Notification.updateMany(
        { recipientId: testUser._id },
        { isRead: true },
      );

      const response = await request(testApp)
        .put(`/api/notifications/users/${testUser._id}/read-all`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.message).toBe('All notifications marked as read');
    });
  });

  describe('GET /api/notifications/:userId/unread-count', () => {
    beforeEach(async () => {
      // Create notifications with mixed read status
      const notifications = [
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post 1',
          blogId: testBlog._id,
          isRead: false,
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'comment',
          message: 'commented on your blog post 2',
          blogId: testBlog._id,
          isRead: false,
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post 3',
          blogId: testBlog._id,
          isRead: true,
        },
      ];

      await Notification.insertMany(notifications);
    });

    it('should return correct unread notification count', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}/unread-count`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.unreadCount).toBe(2);
    });

    it('should return 0 for users with no unread notifications', async () => {
      // Mark all notifications as read
      await Notification.updateMany(
        { recipientId: testUser._id },
        { isRead: true },
      );

      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}/unread-count`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.unreadCount).toBe(0);
    });

    it('should return 400 for invalid user ID format', async () => {
      const response = await request(testApp)
        .get('/api/notifications/invalid-id/unread-count')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(response.body.error).toBe('Invalid user ID format');
    });
  });

  describe('DELETE /api/notifications/users/:userId/clear-read', () => {
    beforeEach(async () => {
      // Create notifications with mixed read status
      const notifications = [
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post 1',
          blogId: testBlog._id,
          isRead: false, // Unread - should not be deleted
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'comment',
          message: 'commented on your blog post 2',
          blogId: testBlog._id,
          isRead: true, // Read - should be deleted
        },
        {
          recipientId: testUser._id,
          senderId: senderUser._id,
          type: 'like',
          message: 'liked your blog post 3',
          blogId: testBlog._id,
          isRead: true, // Read - should be deleted
        },
      ];

      await Notification.insertMany(notifications);
    });

    it('should clear all read notifications', async () => {
      const response = await request(testApp)
        .delete(`/api/notifications/users/${testUser._id}/clear-read`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.message).toBe(
        'All read notifications cleared successfully',
      );
      expect(response.body.deletedCount).toBe(2);

      // Verify only unread notifications remain
      const remainingNotifications = await Notification.find({
        recipientId: testUser._id,
      });
      expect(remainingNotifications.length).toBe(1);
      expect(remainingNotifications[0].isRead).toBe(false);
    });

    it('should return 400 for invalid user ID format', async () => {
      const response = await request(testApp)
        .delete('/api/notifications/users/invalid-id/clear-read')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(400);

      expect(response.body.error).toBe('Invalid user ID format');
    });

    it('should handle users with no read notifications', async () => {
      // Mark all notifications as unread
      await Notification.updateMany(
        { recipientId: testUser._id },
        { isRead: false },
      );

      const response = await request(testApp)
        .delete(`/api/notifications/users/${testUser._id}/clear-read`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.message).toBe(
        'All read notifications cleared successfully',
      );
      expect(response.body.deletedCount).toBe(0);
    });
  });

  describe('Security and Edge Cases', () => {
    it('should handle large pagination values gracefully', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .query({ page: 1000, limit: 1000 })
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.notifications).toBeDefined();
      expect(Array.isArray(response.body.notifications)).toBe(true);
    });

    it('should handle negative pagination values', async () => {
      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .query({ page: -1, limit: -10 })
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      // Should handle gracefully and use defaults or safe values
      expect(response.body.notifications).toBeDefined();
    });

    it('should not expose sensitive user data in populated fields', async () => {
      const notification = new Notification({
        recipientId: testUser._id,
        senderId: senderUser._id,
        type: 'like',
        message: 'liked your blog post',
        blogId: testBlog._id,
        blogTitle: testBlog.blogTitle,
        isRead: false,
      });
      await notification.save();

      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      const returnedNotification = response.body.notifications[0];
      expect(returnedNotification.senderId.password).toBeUndefined();
      expect(returnedNotification.senderId.userName).toBeDefined();
    });

    it('should handle concurrent notification operations', async () => {
      const notification = new Notification({
        recipientId: testUser._id,
        senderId: senderUser._id,
        type: 'like',
        message: 'concurrent test',
        blogId: testBlog._id,
        isRead: false,
      });
      await notification.save();

      // Make concurrent requests to mark as read
      const promises = Array(5)
        .fill(null)
        .map(() =>
          request(testApp)
            .put(`/api/notifications/${notification._id}/read`)
            .set('Authorization', `Bearer ${authToken}`),
        );

      const responses = await Promise.all(promises);

      // All requests should succeed
      responses.forEach((response) => {
        expect(response.status).toBe(200);
        expect(response.body.isRead).toBe(true);
      });
    });

    it('should validate notification type enum values', async () => {
      // Create notification with valid enum value
      const validNotification = new Notification({
        recipientId: testUser._id,
        senderId: senderUser._id,
        type: 'like', // Valid enum value
        message: 'valid type test',
        blogId: testBlog._id,
        isRead: false,
      });
      await validNotification.save();

      const response = await request(testApp)
        .get(`/api/notifications/${testUser._id}`)
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      const notification = response.body.notifications.find(
        (n: any) => n.message === 'valid type test',
      );
      expect(notification).toBeDefined();
      expect(['like', 'comment']).toContain(notification.type);
    });
  });
});
